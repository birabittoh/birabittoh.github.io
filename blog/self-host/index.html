<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Self-hosting Extravaganza</title><meta content="Self-hosting Extravaganza" name=title><meta content="Tech and privacy ramblings from a random italian dude." name=description><meta content=website property=og:type><meta content=https://birabittoh.github.io/blog/self-host/ property=og:url><meta content=BiRabittoh property=og:site_name><meta content="Self-hosting Extravaganza" property=og:title><meta content="Tech and privacy ramblings from a random italian dude." property=og:description><meta content=summary_large_image property=twitter:card><meta content=https://birabittoh.github.io/blog/self-host/ property=twitter:url><meta content="Self-hosting Extravaganza" property=twitter:title><meta content="Tech and privacy ramblings from a random italian dude." property=twitter:description><link href=https://birabittoh.github.io/blog/self-host/ rel=canonical><link href=https://birabittoh.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://birabittoh.github.io/css/style.css rel=stylesheet><body><div class=wrapper><header><nav class=navBar><a href=/>/home/</a><a href=/about>/about/</a><a href=/links>/links/</a><a href=/blog>/blog/</a><div class=themeSwitch><button class="themeButton light" onclick="setTheme('light')" title="Light mode">◐</button><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode">◑</button></div><script>const setTheme=a=>{document.documentElement.className=a;localStorage.setItem(`theme`,a)};const getTheme=()=>{const a=localStorage.getItem(`theme`);const b=a?a:`dark`;setTheme(b)};getTheme()</script></nav><div><a href=..>..</a>/<span class=metaData>self-host</span></div><time datetime=2023-07-16>Published on: <span class=metaData>2023-07-16</span></time><h1>Self-hosting Extravaganza</h1></header><main><p>Lately, more and more companies are putting their services behind paywalls, usage limits and closed APIs. Some examples are <a href=https://nitter.privacydev.net/elonmusk/status/1675187969420828672 rel=noopener target=_blank>Twitter</a> limiting the number of tweets a non-paying user can read, <a href=https://www.redditinc.com/blog/2023apiupdates rel=noopener target=_blank>Reddit</a> increasing their API price to an extent that’s unbearable for any normal individual and <a href=https://redlib.perennialte.ch/r/youtube/comments/14kmd07/youtube_cracking_down_on_if_youre_not_paying_them/ rel=noopener target=_blank>YouTube</a> starting to block their service towards anyone using an adblock extension.<h2 id=there-must-be-a-better-way>There must be a better way</h2><p>Luckily, I’ve been interested in <a href=https://github.com/mendel5/alternative-front-ends rel=noopener target=_blank>alternative front-ends</a> for a while. These services allow you to get the same (or better) functionality as their corporate counterpart without giving away any of your information in return. Some of these even offer their own free APIs.<p>Here’s my favorite instances with respect to the service they provide:<table><thead><tr><th>Service<th>PC<th>Mobile<tbody><tr><td>YouTube<td><a href=https://yewtu.be/ rel=noopener target=_blank>Invidious</a><td><a href=https://apt.izzysoft.de/fdroid/index/apk/org.polymorphicshade.tubular rel=noopener target=_blank>Tubular</a><tr><td>Twitter<td><a href=https://nitter.privacydev.net/ rel=noopener target=_blank>Nitter</a><td><a href=https://apt.izzysoft.de/fdroid/index/apk/org.ca.squawker rel=noopener target=_blank>Squawker</a><tr><td>Reddit<td><a href=https://redlib.perennialte.ch/ rel=noopener target=_blank>RedLib</a><td><a href=https://redlib.perennialte.ch/ rel=noopener target=_blank>RedLib</a><tr><td>Medium<td><a href=https://scribe.rip rel=noopener target=_blank>Scribe</a><td><a href=https://scribe.rip/ rel=noopener target=_blank>Scribe</a></table><h2 id=drawbacks>Drawbacks</h2><p>Of course, this is not a perfect solution. There are a lot of problems to be discussed.<h3 id=privacy>Privacy</h3><p>First and foremost, these instances do not make any profit. This is not a problem until you really think about it. Can you really trust a random developer offering a (paid) service for thousands of users out of their own kindness? The answer is “probably yes”, but are you willing to take this risk?<p>Instance admins could easily edit the upstream source code to make it so they can track their users indefinetly and sell usage data without them even realizing. This is a given if you use any “normal” (not self-hosted) service, but the difference is big companies are <em>required</em> by GDPR to protect collected user data in a certain way and keep them for a maximum set amount of time.<p>The same cannot be assured for individuals who apparently don’t even make a profit for what they’re doing.<h3 id=scaling>Scaling</h3><p>This buzzword has become a meme in the programming world, but it’s been shown how important it is to consider when dealing with large userbases that can grow exponentially without any warning.<p>Think about the amount of users who migrated to Mastodon immediately after Elon Musk acquired Twitter. Instance admins were used to having a couple hundred users, so hundred of thousands of new signups made a lot of popular instances slow down or even temporarily shut down while they migrated to new (and more expensive) hardware.<p>Anything public you use can be subject to this phenomenon, leading to poor user experience, as you’ll be one of the many people wondering why your feed takes one minute to load.<h2 id=fine-i-ll-do-it-myself>Fine, I’ll do it myself</h2><p>Since joining the world of minimalism, I had always considered Docker as a bloated way to run multiple virtual machines. I read about people complaining that even simple Python scripts were providing <code>Dockerfile</code> and <code>compose.yml</code> files and I started seeing it as a bloaty way to achieve the same result.<p>Whenever I wanted to host anything by myself, I used to SSH into my VPS with password authentication (!!!) and expose a public port for each service (!!!). I used my public IP address to log into my services, so I had to resort to sending cleartext passwords through HTTP (!!!) since TLS was not an option.<p>Of course, this is possibly the most insecure way to host services on a public server, but I felt that was “secure enough” and nobody would ever be interested in hacking me (!!! × ∞).<p>Nonetheless, I used to <code>cat /var/log/auth.log</code> to see all the failed login attempts, and pray that nobody actually got my password right. Nowadays, I look back and laugh at my previous config; at least I’m (almost) sure that nobody actually managed to get in.<h2 id=the-right-way>The right way</h2><p>Since I started my new job, I also began experimenting with Docker and found out it’s not as bad as I thought it’d be. I will now let my previous config serve as the perfect example of how NOT to secure your VPS correctly for any self-hosting configuration.<h3 id=ditch-password-authentication>Ditch password authentication</h3><p>First of all, password authentication. You’ll be a lot safer as soon as you disable it.<p>Having it enabled means you’re vulnerable to dictionary and bruteforce attacks. Also, if some new vulnerability is published, the password field is one more way the attacker could send a malicious string to get inside (see <a href=https://scribe.rip/geekculture/the-log4j-incident-explained-ed0ce6d36df2 rel=noopener target=_blank>the log4j incident</a>).<p>A better way of logging into your VPS is through public key authentication.<p>First, generate a key on your own PC:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>ssh-keygen -t ed25519 -a 100
</code></pre><p>This will create two files: <code>~/.ssh/id_ed25519.pub</code> and <code>~/.ssh/id_ed25519</code><p>Now, use the following command to copy your key over to the VPS:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>ssh-copy-id -i ~/.ssh/id_ed25519 &LTuser>@&LTip>
</code></pre><p>At this point, if everything went correctly, just add or change the following lines in <code>/etc/ssh/sshd_config</code> on your VPS:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>PasswordAuthentication no
PermitRootLogin no
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
</code></pre><p>At this point, you should be able to log into your VPS without the need to input your password, which is more secure AND more convenient.<p>I keep the content of my public and private ssh key files saved as secure notes in my BitWarden account, so I can take them to any PC I want to access my VPS from. People say this is bad practice (you should only have a key for each host), but I personally feel like it’s not that big of a deal compared to the security mess I had going on before.<h3 id=containerize-your-applications>Containerize your applications</h3><p>Now that you have a safe way to SSH into your machine, you can start hosting your own services.<p>First, some terminology:<ul><li><code>Dockerfile</code> files are like a list of ingredients. They contain every dependency needed to build a minimal operating system dedicated to running a program. They’re used to build images.<li><code>Images</code> are like recipes. You can create some yourself from a Dockerfile or download them from an external repository. They can be instantiated as containers.<li><code>Containers</code> are like courses. You can instantiate multiple equal courses from the same image and you can actually eat (use) them! They can be managed through <code>docker compose</code>.<li><code>compose.yml</code> files are like menus. They’re a convenient way to instantiate and deinstantiate multiple containers in a specific and reproducible configuration. If you’re not a developer, you’ll be mainly working on these files.</ul><p>To get started with Docker, install <code>docker</code> and <code>docker-compose</code> via your package manager of choice. Let’s try hosting our own <a href=https://github.com/redlib-org/redlib rel=noopener target=_blank>RedLib</a> instance.<p>First, ssh into your VPS and clone the repo:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>git clone https://github.com/redlib-org/redlib
cd redlib
</code></pre><p>Then, create your <code>.env</code> file:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>cp .env.example .env
</code></pre><p>The redlib repo includes a <code>compose.yaml</code> file. You can start the service by running <code>docker compose up -d</code>, then test if you can reach your service by querying http://&LTyour-ip>:8080.<p>When you want to stop the service, just run <code>docker compose down</code> to stop and delete all of its related containers.<h3 id=use-a-reverse-proxy>Use a reverse proxy</h3><p>You should now have exposed port 8080 of your container to the internet.<p>Problem is, you’re still using an IP address and communicating in cleartext through HTTP! This means your ISP can read every single detail in every single request you make.<p>Luckily, there is a way to get a cool domain name for free that also happens to include free and auto-generated TLS certificates.<p>First, create an account on <a href=https://www.duckdns.org/ rel=noopener target=_blank>DuckDNS</a> and set up a free domain.<p>Just make a new directory near the one you used for RedLib and create a new <code>compose.yaml</code> file:<pre><code>mkdir swag
cd swag
nano compose.yaml
</code></pre><p>Here’s a good starting point for <code>compose.yaml</code>:<pre class=language-yaml data-lang=yaml><code class=language-yaml data-lang=yaml>services:
    swag:
        image: 'ghcr.io/linuxserver/swag'
        container_name: 'swag'
        cap_add:
            - 'NET_ADMIN'
        environment:
          PUID: '1000'
          PGID: '1000'
          TZ: 'Europe/Rome'
          URL: '&LTyour-domain>.duckdns.org'
          SUBDOMAINS: 'wildcard'
          VALIDATION: 'duckdns'
          DUCKDNSTOKEN: '&LTyour-token>'
          EMAIL: '&LTyour-email>'
          ONLY_SUBDOMAINS: 'false'
          STAGING: 'false'
        volumes:
            - 'data:/config'
            - './www:/config/www'
            - './proxy-confs:/config/nginx/proxy-confs'
        ports:
            - '443:443'
            - '80:80'
        restart: 'unless-stopped'

volumes:
  data:
</code></pre><p>Check out <a href=https://docs.linuxserver.io/general/swag#creating-a-swag-container rel=noopener target=_blank>this guide</a> if you need more info.<p>When you’re done, start your container with <code>docker compose up -d</code>. This will create the swag_data volume, as well as a new network called <code>swag_default</code> and two directories named <code>www</code> and <code>proxy-confs</code>.<p>Now we need to create a custom subdomain for RedLib. You can do it by creating a new file in <code>proxy-confs</code>:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>cd proxy-confs
nano redlib.subdomain.conf
</code></pre><p>Then paste the following content:<pre class=language-sql data-lang=sql><code class=language-sql data-lang=sql>server {
    listen 443 ssl;
    listen [::]:443 ssl;

    http2 on;

    server_name r.*;

    include /config/nginx/ssl.conf;

    client_max_body_size 0;

    location / {
        include /config/nginx/proxy.conf;
        include /config/nginx/resolver.conf;
        set $upstream_app redlib;
        set $upstream_port 8080;
        set $upstream_proto http;
        proxy_pass $upstream_proto://$upstream_app:$upstream_port;
    }
}
</code></pre><p>Where:<ul><li><code>server_name r.*</code>: <code>r</code> is your subdomain of choice;<li><code>set $upstream_app redlib;</code>: <code>redlib</code> is the name of the RedLib container;<li><code>set $upstream_port 8080;</code>: <code>8080</code> is the RedLib port.</ul><p>There’s one last step remaining. RedLib and Swag are two separate containers, so they cannot communicate unless they’re connected to the same network.<p>RedLib’s <code>compose.yaml</code> specifies a custom <code>redlib</code> network, while swag has its own <code>swag_default</code> network. Instead of the <code>redlib</code> network, we want our RedLib container to connect to <code>swag_default</code>. To do this, cd to your <code>redlib</code> directory and make your own copy of <code>compose.yaml</code>:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>cd ~/redlib
cp compose.yaml compose.custom.yaml
nano compose.custom.yaml
</code></pre><p>Now we can remove the <code>ports</code> section and add <code>swag_default</code> as an external network the container should connect to.<p>The final result should look something like this:<pre class=language-yaml data-lang=yaml><code class=language-yaml data-lang=yaml>services:
  redlib:
    image: quay.io/redlib/redlib:latest
    restart: always
    container_name: "redlib"
    user: nobody
    read_only: true
    security_opt:
      - no-new-privileges:true
      # - seccomp=seccomp-redlib.json
    cap_drop:
      - ALL
    env_file: .env
    networks:
      - swag_default # changed
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "--tries=1", "http://localhost:8080/settings"]
      interval: 5m
      timeout: 3s

networks:
  swag_default: # changed
    external: true # changed
</code></pre><p>Then, apply your updates by stopping the old configuration and starting the new one:<pre class=language-sh data-lang=sh><code class=language-sh data-lang=sh>docker compose down
docker compose -f compose.custom.yaml up -d
</code></pre><p>Finally, you can visit https://r.&LTyour-domain>.duckdns.org/ and check if you can access RedLib through HTTPS.<p>Ideally, the only container with exposed ports in your VPS should be Swag exposing ports 80 (HTTP) and 443 (HTTPS).<h2 id=conclusion>Conclusion</h2><p>Self-hosting is not easy. It’s been my <a href=https://wiki.froth.zone/wiki/Camino_de_Santiago rel=noopener target=_blank>Camino de Santiago</a>: a long path of redemption for the sins I have committed in my young age. Even if I made a lot of mistakes, in the end I’ve learned a lot about dev-ops and cybersecurity, as well as precious skills that proved themselves useful for my engineering job.<p>You can find a full list of self-hostable services <a href=https://github.com/awesome-selfhosted/awesome-selfhosted rel=noopener target=_blank>here</a>!</main><footer><p class=tagsData><a href=/tags/advice>#advice</a> <a href=/tags/foss>#foss</a> <a href=/tags/privacy>#privacy</a><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br> Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/BiRabittoh/anemone target=_blank>anemone</a> theme & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a> colors.<br></div><div class=footRight><a href=https://wobble.town/visit/528 target=_blank><img class="footGif noStyle" alt=footGif loading=lazy src=https://wobble.town/visit/528/wobble.gif></a><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://birabittoh.github.io/atom.xml target=_blank>RSS</a></div></div></footer></div>